<?php	/* Utils.php												[	DVR-Web Framework	]
		- Utilities and Helper Functions								[  (c) ender@enderboi.com 2015  ]	*/

	/*
	Functions:
		sendFile_Rangable($filename, $contentType): Stream file to browser as content-type. Supports RANGE header for resumable/seekable downloads.
		makeThumbnail($filename, $cacheDir, $sz): Make image thumbnail ($sz[0] by $sz[1] pixels). If possible, cache generated thumbs in $cacheDir..
		dateOffset($dateString, $offsetString): Return a Y-m-d date based off $dateStamp with a offset of $offset (eg, '-1 days', '6 hours', etc).
	*/

	//////////////////////////////////////////////////////////////
	// ** dateOffset($dateString, $offsetString): Return a Y-m-d date based off $dateStamp with a offset of $offset (eg, '-1 days', '6 hours', etc).
        function dateOffset($dateStamp, $offset) {return date('Y-m-d', strtotime($dateStamp . ' ' . $offset));}

	// ** makeThumbnail($filename, $cacheDir, $sz): Make image thumbnail ($sz[0] by $sz[1] pixels). If possible, cache generated thumbs in $cacheDir..
	function makeThumbnail($ImageFile, $CacheFolder = "", $ThumbSize = array("300", "200")) {
		global $hostConfig;

	        @mkdir($CachePath);
		$ImageName = basename($ImageFile);
		$ThumbFile = "$CacheFolder/$ImageName";

	        header("Content-Type: image/jpeg");

		// Use a cached copy of the Thumbnail, if it exists (and has a valid size)
       		if (file_exists($ThumbFile)) {
			if (filesize($ThumbFile) >= 1500)
		        	return readfile($ThumbFile);
			unlink($ThumbFile);	// If <1500bytes, assume this thumbnail is corrupt. Delete it from disk, to be re-generated by the code below..
		} 

		// Generate a new thumbnail
               	$thumb = imagecreatetruecolor($ThumbSize[0], $ThumbSize[1]);
               	fastimagecopyresampled($ImageFile, $thumb, $ThumbSize[0], $ThumbSize[1]);
              	imagejpeg($thumb, "/tmp/$ImageName.tmp", 90);

		// Display image
		imagejpeg($thumb);

		// Copy into the cache		** NOTE: Using a shell exec, because imagejpeg() writes 0-byte files to the CIFS share under Docker (@ 12/09/15)
               	echo `cp /tmp/$ImageName.tmp $ThumbFile`;	

		exit(0);
	}

        // ** sendFile_Rangable($filename, $contentType): Stream file to browser as content-type. Supports RANGE header for resumable/seekable downloads.
	function sendFile_Rangable($filename, $contentType = "binary/octet") {
		if (!file_exists($filename))
			return Framework::debug(DEBUG_FATAL, "sendFile_Ranagable() - Unknown file $filename");

		header("Content-Type: $contentType");
		$fp = @fopen($filename, 'rb'); 
		header("Accept-Ranges: bytes"); 
		$size = filesize($filename); // File size 
		$length = $size; // Content length
		$start = 0; // Start byte 
		$end = $size - 1; // End byte 

		if (isset($_SERVER['HTTP_RANGE'])) {
		    $c_start = $start; 
		    $c_end = $end; 
		    list(, $range) = explode('=', $_SERVER['HTTP_RANGE'], 2); 

		    if (strpos($range, ',') !== false) { 
			header('HTTP/1.1 416 Requested Range Not Satisfiable');
		        header("Content-Range: bytes $start-$end/$size");
		        exit;
		    }

		    if ($range == '-') {
		        $c_start = $size - substr($range, 1);
		    }else{
		        $range = explode('-', $range);
		        $c_start = $range[0];
		        $c_end = (isset($range[1]) && is_numeric($range[1])) ? $range[1] : $size;
		    }

		    $c_end = ($c_end > $end) ? $end : $c_end;
		    if ($c_start > $c_end || $c_start > $size - 1 || $c_end >= $size) {
		        header('HTTP/1.1 416 Requested Range Not Satisfiable');
		        header("Content-Range: bytes $start-$end/$size");
		        exit;
		    }

		    $start = $c_start;
		    $end = $c_end;
		    $length = $end - $start + 1;
		    fseek($fp, $start);
		    header('HTTP/1.1 206 Partial Content');
		}

		header("Content-Range: bytes $start-$end/$size"); header("Content-Length: ".$length); $buffer = 1024 * 8; while(!feof($fp) && ($p = ftell($fp)) <= $end) {
		if ($p + $buffer > $end)
			$buffer = $end - $p + 1;

		set_time_limit(0);
		echo fread($fp, $buffer);
		flush();
	}
	fclose($fp);
	exit();
}



	function fastimagecopyresampled ($imgSrc, &$dst_image,$dst_w, $dst_h, $quality = 3) {
	  // Plug-and-Play fastimagecopyresampled function replaces much slower imagecopyresampled.
	  // Typically from 30 to 60 times faster when reducing high resolution images down to thumbnail size using the default quality setting.
	  // Author: Tim Eckel - Date: 09/07/07 - Version: 1.1 - Project: FreeRingers.net - Freely distributable - These comments must remain.
	  //
	  // Optional "quality" parameter (defaults is 3). Fractional values are allowed, for example 1.5. Must be greater than zero.
	  // Between 0 and 1 = Fast, but mosaic results, closer to 0 increases the mosaic effect.
	  // 1 = Up to 350 times faster. Poor results, looks very similar to imagecopyresized.
  	  // 2 = Up to 95 times faster.  Images appear a little sharp, some prefer this over a quality of 3.
	  // 3 = Up to 60 times faster.  Will give high quality smooth results very close to imagecopyresampled, just faster.
  	  // 4 = Up to 25 times faster.  Almost identical to imagecopyresampled for most images.
  	  // 5 = No speedup. Just uses imagecopyresampled, no advantage over imagecopyresampled.
    	list($src_w, $src_h) = getimagesize($imgSrc);
    	$src_image  = imagecreatefromjpeg($imgSrc);
	$src_y = $src_x = $dst_y = $dst_x = 0;

 	if (empty($src_image) || empty($dst_image) || $quality <= 0) { return false; }
  		if ($quality < 5 && (($dst_w * $quality) < $src_w || ($dst_h * $quality) < $src_h)) {
    			$temp = imagecreatetruecolor ($dst_w * $quality + 1, $dst_h * $quality + 1);
		    	imagecopyresized ($temp, $src_image, 0, 0, $src_x, $src_y, $dst_w * $quality + 1, $dst_h * $quality + 1, $src_w, $src_h);
		    	imagecopyresampled ($dst_image, $temp, $dst_x, $dst_y, 0, 0, $dst_w, $dst_h, $dst_w * $quality, $dst_h * $quality);
		    	imagedestroy ($temp);
  		} else 
			imagecopyresampled ($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h);
  		return true;
	}
